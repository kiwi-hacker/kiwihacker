<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>레이저에서 버티기</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
            margin: 0;
            font-family: 'Inter', sans-serif; /* Inter 폰트 사용 */
            color: #eee;
            overflow: hidden; /* 스크롤바 방지 */
        }

        #game-container {
            position: relative;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            overflow: hidden;
            border-radius: 15px; /* 둥근 모서리 */
            display: flex; /* Flexbox를 사용하여 내부 요소를 중앙 정렬 */
            flex-direction: column; /* 세로 정렬 */
            align-items: center; /* 가로 중앙 정렬 */
            justify-content: center; /* 세로 중앙 정렬 */
        }

        #gameCanvas {
            background-color: #000;
            display: block;
            /* width와 height는 JS에서 동적으로 설정 */
            max-width: 100vw; /* 뷰포트 너비를 넘지 않도록 */
            max-height: 100vh; /* 뷰포트 높이를 넘지 않도록 */
        }

        #game-ui {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column; /* 세로 정렬 */
            gap: 15px; /* 간격 줄임 */
            font-size: 1.6em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #score {
            color: #44ff44;
        }

        /* 체력 바 스타일 */
        #health-bar-container {
            width: 200px; /* 체력 바 전체 너비 */
            height: 25px; /* 체력 바 높이 */
            background-color: #333;
            border: 2px solid #555;
            border-radius: 10px;
            overflow: hidden; /* 내부 바가 넘치지 않도록 */
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); /* 붉은색 그림자 */
        }

        #health-bar {
            height: 100%;
            width: 100%; /* 초기 100% */
            background: linear-gradient(to right, #ff0000, #ff8800); /* 빨강-주황 그라디언트 */
            border-radius: 8px; /* 내부 바 둥근 모서리 */
            transition: width 0.2s ease-out, background 0.5s ease; /* 너비 및 색상 전환 애니메이션 */
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 40px 60px;
            border-radius: 20px; /* 둥근 모서리 */
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.6);
            display: none; /* 초기에는 숨김 */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100; /* 다른 요소 위에 표시 */
        }

        #game-over h2 {
            color: #fff;
            margin-bottom: 25px;
            font-size: 3em;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
        }

        #game-over button {
            background: linear-gradient(145deg, #00aaff, #0077cc); /* 그라디언트 배경 */
            color: white;
            border: none;
            padding: 18px 35px;
            font-size: 1.4em;
            border-radius: 10px; /* 둥근 모서리 */
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 170, 255, 0.4); /* 그림자 */
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px; /* 버튼 아래 간격 추가 */
        }

        #game-over button:hover {
            background: linear-gradient(145deg, #0088cc, #005599);
            transform: translateY(-3px); /* 약간 위로 이동 */
            box-shadow: 0 8px 20px rgba(0, 170, 255, 0.6);
        }

        #game-over button:active {
            transform: translateY(0); /* 클릭 시 원위치 */
            box-shadow: 0 3px 10px rgba(0, 170, 255, 0.3);
        }

        /* 비밀번호 섹션 스타일 */
        #secret-invincibility-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }

        #passwordInput {
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #00aaff;
            background-color: #333;
            color: #eee;
            font-size: 1.1em;
            outline: none;
            width: 200px;
            text-align: center;
        }

        #submitPasswordButton {
            background: linear-gradient(145deg, #4CAF50, #45a049); /* 초록색 계열 */
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(76, 175, 80, 0.4);
        }

        #submitPasswordButton:hover {
            background: linear-gradient(145deg, #45a049, #367c39);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.6);
        }

        #passwordMessage {
            font-size: 1em;
            font-weight: bold;
        }

        /* '무적으로 플레이' 버튼 스타일 */
        #playInvincibleButton {
            background: linear-gradient(145deg, #FFD700, #FFA500); /* 황금색 계열 */
            color: #333;
            border: none;
            padding: 18px 35px;
            font-size: 1.4em;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            display: none; /* 초기에는 숨김 */
        }

        #playInvincibleButton:hover {
            background: linear-gradient(145deg, #FFC107, #FF8C00);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 215, 0, 0.6);
        }

        /* '관리자 모드로 플레이' 버튼 스타일 */
        #playAdminButton {
            background: linear-gradient(145deg, #a020f0, #8a2be2); /* 보라색 계열 */
            color: white;
            border: none;
            padding: 18px 35px;
            font-size: 1.4em;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(160, 32, 240, 0.4);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            display: none; /* 초기에는 숨김 */
        }

        #playAdminButton:hover {
            background: linear-gradient(145deg, #8a2be2, #6a0dad);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(160, 32, 240, 0.6);
        }

        /* '하드모드로 플레이' 버튼 스타일 */
        #playHardModeButton {
            background: linear-gradient(145deg, #ff4500, #dc143c); /* 주황-빨강 계열 */
            color: white;
            border: none;
            padding: 18px 35px;
            font-size: 1.4em;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 69, 0, 0.4);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            display: none; /* 초기에는 숨김 */
        }

        #playHardModeButton:hover {
            background: linear-gradient(145deg, #dc143c, #b22222);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 69, 0, 0.6);
        }

        /* 눈뽕 효과 오버레이 */
        #blind-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0); /* 초기 투명 */
            pointer-events: none; /* 클릭 이벤트 통과 */
            transition: background-color 0.1s ease-out; /* 부드러운 전환 */
            z-index: 99; /* 게임 오버 스크린보다 아래 */
        }

        /* 관리자 패널 스타일 */
        #admin-panel {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            display: none; /* 초기에는 숨김 */
            flex-direction: column;
            gap: 10px;
            z-index: 101; /* 게임 오버 스크린보다 위 */
        }

        #admin-panel button {
            background: linear-gradient(145deg, #6a0dad, #4b0082); /* 보라색 계열 */
            color: white;
            border: none;
            padding: 10px 15px;
            font-size: 0.9em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(106, 13, 173, 0.4);
        }

        #admin-panel button:hover {
            background: linear-gradient(145deg, #4b0082, #2e0050);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(106, 13, 173, 0.6);
        }

        /* 반응형 디자인 */
        @media (max-width: 820px) {
            #gameCanvas {
                width: 100vw;
                height: calc(100vw * 0.75); /* 4:3 비율 유지 */
            }
            #game-ui {
                font-size: 1.2em;
                gap: 10px;
            }
            #health-bar-container {
                width: 150px; /* 모바일에서 체력 바 너비 줄임 */
                height: 20px;
            }
            #game-over {
                padding: 20px 30px;
                border-radius: 15px;
            }
            #game-over h2 {
                font-size: 2em;
            }
            #game-over button, #playInvincibleButton, #playAdminButton, #playHardModeButton { /* ID 업데이트 */
                padding: 12px 25px;
                font-size: 1em;
            }
            #passwordInput {
                width: 150px;
                font-size: 1em;
            }
            #submitPasswordButton {
                padding: 8px 15px;
                font-size: 1em;
            }
            #admin-panel {
                top: auto;
                bottom: 15px;
                right: 50%;
                transform: translateX(50%);
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
                padding: 10px;
            }
            #admin-panel button {
                padding: 8px 12px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="game-ui">
            <div id="score">점수: 0</div>
            <div id="health-bar-container">
                <div id="health-bar"></div>
            </div>
        </div>
        <div id="game-over">
            <h2>게임 오버!</h2>
            <button id="restartButton">다시 시작</button>
            <button id="playInvincibleButton">무적으로 플레이</button> <!-- 무적 모드 버튼 -->
            <button id="playAdminButton">관리자 모드로 플레이</button> <!-- 관리자 모드 버튼 -->
            <button id="playHardModeButton">하드모드로 플레이</button> <!-- 하드 모드 버튼 -->
            <div id="secret-invincibility-section" style="display:none;">
                <input type="password" id="passwordInput" placeholder="비밀번호 입력">
                <button id="submitPasswordButton">확인</button>
                <p id="passwordMessage"></p>
            </div>
        </div>
        <div id="blind-overlay"></div>

        <!-- 관리자 패널 -->
        <div id="admin-panel">
            <h3>관리자 패널</h3>
            <button id="addScoreButton">점수 10000 추가</button>
            <button id="toggleScoreBuffButton">점수 오르기 버프</button>
            <button id="toggleInvincibilityButton">무적 토글</button>
            <button id="resetGameButton">다시하기</button>
            <button id="increaseSpeedButton">스피드 증가</button>
            <button id="decreaseSpeedButton">스피드 감소</button>
            <button id="increaseSizeButton">크기 늘리기</button>
            <button id="decreaseSizeButton">크기 줄이기</button>
            <button id="hardModeButton">하드모드!</button>
        </div>
    </div>

    <script type="module">
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const healthBarContainer = document.getElementById('health-bar-container');
        const healthBar = document.getElementById('health-bar');
        const gameOverScreen = document.getElementById('game-over');
        const restartButton = document.getElementById('restartButton');
        const playInvincibleButton = document.getElementById('playInvincibleButton'); // 무적 모드 버튼
        const playAdminButton = document.getElementById('playAdminButton'); // 관리자 모드 버튼
        const playHardModeButton = document.getElementById('playHardModeButton'); // 하드 모드 버튼
        const blindOverlay = document.getElementById('blind-overlay');
        const secretInvincibilitySection = document.getElementById('secret-invincibility-section');
        const passwordInput = document.getElementById('passwordInput');
        const submitPasswordButton = document.getElementById('submitPasswordButton');
        const passwordMessage = document.getElementById('passwordMessage');
        const adminPanel = document.getElementById('admin-panel'); // 관리자 패널 요소

        // 관리자 패널 버튼들
        const addScoreButton = document.getElementById('addScoreButton');
        const toggleScoreBuffButton = document.getElementById('toggleScoreBuffButton'); // 새 점수 버프 버튼
        const toggleInvincibilityButton = document.getElementById('toggleInvincibilityButton');
        const resetGameButton = document.getElementById('resetGameButton');
        const increaseSpeedButton = document.getElementById('increaseSpeedButton');
        const decreaseSpeedButton = document.getElementById('decreaseSpeedButton');
        const increaseSizeButton = document.getElementById('increaseSizeButton');
        const decreaseSizeButton = document.getElementById('decreaseSizeButton');
        const hardModeButton = document.getElementById('hardModeButton'); // 새 하드 모드 버튼

        canvas.width = 800;
        canvas.height = 600;

        let player;
        let lasers = [];
        let redBlocks = [];
        let guidedBlocks = [];
        let purpleBlocks = [];
        let orangePanels = [];
        let greenHealBlocks = [];

        let score = 0;
        let health = 100;
        let gameOver = false;
        let stunned = false;
        let blindEffect = false;
        let playerInvincible = false;
        let isAdminMode = false; // 관리자 모드 플래그
        let isInvincibleOnlyMode = false; // 무적 전용 모드 플래그
        let fastScoreMode = false; // 점수 버프 플래그
        let isHardMode = false; // 하드 모드 플래그
        let gameStartTime = 0;

        let lastActivatedMode = 'normal'; // 'normal', 'invincible', 'admin', 'hard'

        const INVINCIBILITY_DURATION = 3000;
        const LASER_START_DELAY = 15000;
        const RED_BLOCK_DAMAGE = 20;
        const MAX_LASERS = 3;

        // Hard Mode specific constants
        const HARD_MODE_PLAYER_SPEED_DECREASE = 2; // 플레이어 속도 감소량
        const HARD_MODE_ENEMY_SPEED_MULTIPLIER = 1.8; // 장애물 속도 증가 배율 (매우 올라가)

        let restartButtonHoldTimer = null;
        let restartButtonHoldStartTime = 0;
        const SECRET_INVINCIBILITY_HOLD_TIME = 15000; // 15초

        let isDragging = false;
        let lastMouseX = 0; // 드래그 계산을 위한 마지막 마우스 위치 저장
        let lastMouseY = 0;
        let lastTouchX = 0; // 드래그 계산을 위한 마지막 터치 위치 저장
        let lastTouchY = 0;

        // 플레이어 클래스
        class Player {
            constructor() {
                this.size = 20;
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.color = 'lime';
                this.speed = 5; // 초기 플레이어 속도
                this.dx = 0;
                this.dy = 0;
            }

            draw() {
                if (stunned) {
                    ctx.fillStyle = 'gray';
                } else if (playerInvincible && Math.floor(performance.now() / 100) % 2 === 0) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                } else {
                    ctx.fillStyle = this.color;
                }
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }

            update() {
                if (stunned) {
                    this.dx = 0;
                    this.dy = 0;
                    return; 
                }
                
                // 키보드 또는 드래그 이벤트에 의해 설정된 dx 및 dy 적용
                this.x += this.dx;
                this.y += this.dy;

                // 경계 확인
                if (this.x - this.size / 2 < 0) this.x = this.size / 2;
                if (this.x + this.size / 2 > canvas.width) this.x = canvas.width - this.size / 2;
                if (this.y - this.size / 2 < 0) this.y = this.size / 2;
                if (this.y + this.size / 2 > canvas.height) this.y = canvas.height - this.size / 2;
            }
        }

        // 레이저 클래스
        class Laser {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.length = Math.max(canvas.width, canvas.height) * 1.5;
                this.width = 8;
                this.color = 'rgba(0, 255, 200, 0.8)';
                this.angle = Math.random() * Math.PI * 2;
                // 하드 모드에서 레이저 회전 속도 증가
                this.rotationSpeed = (Math.random() - 0.5) * 0.04 * (isHardMode ? HARD_MODE_ENEMY_SPEED_MULTIPLIER : 1); 
                this.glowColor = 'rgba(0, 255, 200, 0.4)';
                this.glowRadius = 15;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                ctx.shadowBlur = this.glowRadius;
                ctx.shadowColor = this.glowColor;
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width / 2, -this.length / 2, this.width, this.length);
                ctx.restore();

                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }

            update() {
                this.angle += this.rotationSpeed;
            }

            checkCollisionWithPlayer(player) {
                const startX = this.x + Math.cos(this.angle) * (-this.length / 2);
                const startY = this.y + Math.sin(this.angle) * (-this.length / 2);
                const endX = this.x + Math.cos(this.angle) * (this.length / 2);
                const endY = this.y + Math.sin(this.angle) * (this.length / 2);

                let dx = endX - startX;
                let dy = endY - startY;
                const lenSq = dx * dx + dy * dy;
                let t = 0;
                if (lenSq !== 0) {
                    t = ((player.x - startX) * dx + (player.y - startY) * dy) / lenSq;
                    t = Math.max(0, Math.min(1, t));
                }

                const closestX = startX + t * dx;
                const closestY = startY + t * dy;

                const distSq = (player.x - closestX) * (player.x - closestX) + (player.y - closestY) * (player.y - closestY);

                return distSq <= (player.size / 2 + this.width / 2) * (player.size / 2 + this.width / 2);
            }
        }

        // 빨간 블록 클래스
        class RedBlock {
            constructor() {
                this.size = 50;
                this.x = Math.random() * (canvas.width - this.size);
                this.y = -this.size;
                // 하드 모드에서 속도 증가
                this.speed = (3 + Math.random() * 2) * (isHardMode ? HARD_MODE_ENEMY_SPEED_MULTIPLIER : 1); 
                this.color = 'red';
                this.glowColor = 'rgba(255, 0, 0, 0.5)';
                this.glowRadius = 10;
            }

            draw() {
                ctx.shadowBlur = this.glowRadius;
                ctx.shadowColor = this.glowColor;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }

            update() {
                this.y += this.speed;
            }
        }

        // 유도 블록 클래스
        class GuidedBlock {
            constructor(targetPlayer) {
                this.size = 15;
                this.x = Math.random() * (canvas.width - this.size);
                this.y = Math.random() < 0.5 ? -this.size : canvas.height + this.size;
                this.color = 'red';
                // 하드 모드에서 속도 증가
                this.speed = 2 * (isHardMode ? HARD_MODE_ENEMY_SPEED_MULTIPLIER : 1); 
                this.target = targetPlayer;
                this.activeDamage = false;
                this.glowColor = 'rgba(255, 0, 0, 0.6)';
                this.glowRadius = 8;
            }

            draw() {
                ctx.shadowBlur = this.glowRadius;
                ctx.shadowColor = this.glowColor;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }

            update() {
                if (!this.target) return;

                const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
            }
        }

        // 보라색 블록 클래스
        class PurpleBlock {
            constructor() {
                this.size = 30;
                this.x = Math.random() * (canvas.width - this.size);
                this.y = -this.size;
                // 하드 모드에서 속도 증가
                this.speed = 4 * (isHardMode ? HARD_MODE_ENEMY_SPEED_MULTIPLIER : 1); 
                this.color = 'purple';
                this.glowColor = 'rgba(128, 0, 128, 0.7)';
                this.glowRadius = 12;
            }

            draw() {
                ctx.shadowBlur = this.glowRadius;
                ctx.shadowColor = this.glowColor;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }

            update() {
                this.y += this.speed;
            }
        }

        // 주황색 패널 클래스
        class OrangePanel {
            constructor() {
                this.width = canvas.width;
                this.height = canvas.height / 3;
                this.x = 0;
                this.y = -this.height;
                // 하드 모드에서 속도 증가
                this.speed = 2 * (isHardMode ? HARD_MODE_ENEMY_SPEED_MULTIPLIER : 1); 
                this.color = 'rgba(255, 165, 0, 0.5)';
                this.triggered = false;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            update() {
                this.y += this.speed;
            }
        }

        // 녹색 회복 블록 클래스
        class GreenHealBlock {
            constructor() {
                this.initialSize = 40;
                this.size = this.initialSize;
                this.x = Math.random() * (canvas.width - this.size);
                this.y = Math.random() * (canvas.height - this.size);
                this.color = 'limegreen';
                this.lifeTime = 3000;
                this.startTime = performance.now();
                this.glowColor = 'rgba(50, 205, 50, 0.7)';
                this.glowRadius = 10;
                this.rotation = 0;
                this.rotationSpeed = 0.1;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.size / 2, this.y + this.size / 2);
                ctx.rotate(this.rotation);

                ctx.shadowBlur = this.glowRadius;
                ctx.shadowColor = this.glowColor;
                ctx.fillStyle = this.color;

                const numCircles = 8;
                const radiusStep = this.size / 2 / numCircles;
                for (let i = 0; i < numCircles; i++) {
                    const currentRadius = radiusStep * (i + 1);
                    ctx.beginPath();
                    ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();

                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }

            update() {
                const elapsed = performance.now() - this.startTime;
                if (elapsed > this.lifeTime) {
                    this.size = 0;
                } else {
                    this.size = this.initialSize * (1 - (elapsed / this.lifeTime));
                    this.rotation += this.rotationSpeed;
                }
            }
        }

        // 게임 초기화 함수
        function init() {
            player = new Player();
            lasers = [];
            redBlocks = [];
            guidedBlocks = [];
            purpleBlocks = [];
            orangePanels = [];
            greenHealBlocks = [];
            
            gameOver = false;
            stunned = false;
            blindEffect = false;
            playerInvincible = false; // 기본적으로 무적 아님
            isAdminMode = false; // 관리자 모드 플래그 초기화
            isInvincibleOnlyMode = false; // 무적 전용 모드 플래그 초기화
            fastScoreMode = false; // 점수 버프 플래그 초기화
            isHardMode = false; // 하드 모드 플래그 초기화
            lastActivatedMode = 'normal'; // 마지막 활성화 모드 기본값으로 초기화

            // 기본 게임 값 설정
            score = 0;
            health = 100;
            player.size = 20;
            player.speed = 5;

            scoreDisplay.textContent = `점수: ${score}`;
            gameOverScreen.style.display = 'none';
            playInvincibleButton.style.display = 'none'; // 무적 버튼 숨김
            playAdminButton.style.display = 'none'; // 관리자 버튼 숨김
            playHardModeButton.style.display = 'none'; // 하드 모드 버튼 숨김
            adminPanel.style.display = 'none'; // 관리자 패널 숨김
            blindOverlay.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            secretInvincibilitySection.style.display = 'none';
            passwordInput.value = '';
            passwordMessage.textContent = '';

            updateHealthBar();

            // 초기 3초 무적 (일반 플레이에서만)
            playerInvincible = true;
            setTimeout(() => {
                // 관리자/무적 전용/하드 모드가 아니면 무적 해제
                if (!isAdminMode && !isInvincibleOnlyMode && !isHardMode) {
                    playerInvincible = false;
                }
            }, INVINCIBILITY_DURATION);

            gameStartTime = performance.now();
        }

        // 무적 전용 모드로 게임 시작 함수 ('김하진바보이지우천재!'용)
        function startGameWithInvincibilityOnly() {
            init(); // 게임 상태 초기화
            playerInvincible = true; // 무적 활성화
            isInvincibleOnlyMode = true; // 무적 전용 모드 플래그 설정
            isAdminMode = false; // 관리자 모드 비활성화
            fastScoreMode = false; // 점수 버프 비활성화
            isHardMode = false; // 하드 모드 비활성화
            lastActivatedMode = 'invincible';
            gameOverScreen.style.display = 'none'; // 게임 오버 화면 숨김
            adminPanel.style.display = 'none'; // 관리자 패널 숨김
            gameLoop(); // 게임 루프 시작
        }

        // 관리자 모드로 게임 시작 함수 ('성기없찐이~~!'용)
        function startGameWithAdminMode() {
            init(); // 게임 상태 초기화
            playerInvincible = true; // 무적 활성화
            isAdminMode = true; // 관리자 모드 플래그 설정
            isInvincibleOnlyMode = false; // 무적 전용 모드 비활성화
            fastScoreMode = true; // 점수 버프 활성화
            isHardMode = false; // 하드 모드 비활성화
            lastActivatedMode = 'admin';
            gameOverScreen.style.display = 'none'; // 게임 오버 화면 숨김
            adminPanel.style.display = 'flex'; // 관리자 패널 표시
            gameLoop(); // 게임 루프 시작
        }

        // 하드 모드로 게임 시작 함수
        function startGameInHardMode() {
            init(); // 게임 상태 초기화
            isHardMode = true; // 하드 모드 플래그 설정
            playerInvincible = false; // 하드 모드에서는 무적 없음
            isAdminMode = false; // 관리자 모드 비활성화
            isInvincibleOnlyMode = false; // 무적 전용 모드 비활성화
            fastScoreMode = false; // 점수 버프 비활성화
            lastActivatedMode = 'hard';
            gameOverScreen.style.display = 'none'; // 게임 오버 화면 숨김
            adminPanel.style.display = 'none'; // 관리자 패널 숨김
            
            // 하드 모드 전용 초기화
            health = Math.floor(health / 2); // 체력 절반
            player.speed = Math.max(1, player.speed - HARD_MODE_PLAYER_SPEED_DECREASE); // 속도 감소
            updateHealthBar(); // 체력 바 업데이트
            gameLoop(); // 게임 루프 시작
        }

        // 체력 바 업데이트 함수
        function updateHealthBar() {
            healthBar.style.width = `${Math.max(0, health)}%`;
            if (health > 70) {
                healthBar.style.background = 'linear-gradient(to right, #00ff00, #00bb00)';
            } else if (health > 30) {
                healthBar.style.background = 'linear-gradient(to right, #ffff00, #ffaa00)';
            } else {
                healthBar.style.background = 'linear-gradient(to right, #ff0000, #ff8800)';
            }
        }

        // 게임 루프
        function gameLoop() {
            // 게임 오버 시 게임 루프 중지
            if (gameOver) {
                gameOverScreen.style.display = 'flex';
                // 항상 다시 시작 버튼 표시
                restartButton.style.display = 'block';

                // 모든 특정 모드 버튼 초기 숨김
                playInvincibleButton.style.display = 'none';
                playAdminButton.style.display = 'none';
                playHardModeButton.style.display = 'none';

                // 마지막 활성화된 모드에 해당하는 버튼 표시
                if (lastActivatedMode === 'invincible') {
                    playInvincibleButton.style.display = 'block';
                } else if (lastActivatedMode === 'admin') {
                    playAdminButton.style.display = 'block';
                } else if (lastActivatedMode === 'hard') {
                    playHardModeButton.style.display = 'block';
                }

                secretInvincibilitySection.style.display = 'none'; // 비밀번호 섹션 숨김
                adminPanel.style.display = 'none'; // 관리자 패널 숨김
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (blindEffect) {
                blindOverlay.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            } else {
                blindOverlay.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            }

            player.update();
            player.draw();

            lasers.forEach(laser => {
                laser.update();
                laser.draw();
                if (!stunned && !playerInvincible && laser.checkCollisionWithPlayer(player)) {
                    health -= 1;
                    if (health <= 0) gameOver = true;
                }
            });

            redBlocks.forEach((block, index) => {
                block.update();
                block.draw();

                if (!playerInvincible && checkCollisionCircleRect(player, block)) {
                    health -= RED_BLOCK_DAMAGE;
                    if (health <= 0) gameOver = true;
                    redBlocks.splice(index, 1);
                }
                if (block.y > canvas.height) {
                    redBlocks.splice(index, 1);
                    if (!isHardMode) { // 하드 모드가 아니면 회피 점수 획득
                        score += fastScoreMode ? 10 : 1; // 관리자 모드에서 빠른 점수 획득
                    }
                }
            });

            guidedBlocks.forEach((block, index) => {
                block.update();
                block.draw();

                if (!playerInvincible && checkCollisionCircleRect(player, block)) {
                    health -= 10;
                    if (health <= 0) gameOver = true;
                    guidedBlocks.splice(index, 1);
                }
                if (block.y > canvas.height + block.size || block.y < -block.size || block.x > canvas.width + block.size || block.x < -block.size) {
                    guidedBlocks.splice(index, 1);
                }
            });

            purpleBlocks.forEach((block, index) => {
                block.update();
                block.draw();

                if (!playerInvincible && checkCollisionCircleRect(player, block)) {
                    if (!stunned) {
                        stunned = true;
                        player.dx = 0; // 스턴 시 움직임 중지
                        player.dy = 0;
                        setTimeout(() => {
                            stunned = false;
                        }, 5000);
                    }
                    purpleBlocks.splice(index, 1);
                }
                if (block.y > canvas.height) {
                    purpleBlocks.splice(index, 1);
                    if (!isHardMode) { // 하드 모드가 아니면 회피 점수 획득
                        score += fastScoreMode ? 10 : 1; // 관리자 모드에서 빠른 점수 획득
                    }
                }
            });

            orangePanels.forEach((panel, index) => {
                panel.update();
                panel.draw();

                if (!panel.triggered && panel.y + panel.height / 2 >= canvas.height / 2 && panel.y + panel.height / 2 < canvas.height / 2 + panel.speed * 2) {
                    blindEffect = true;
                    panel.triggered = true;
                    setTimeout(() => {
                        blindEffect = false;
                    }, 3000);
                }
                if (panel.y > canvas.height) {
                    orangePanels.splice(index, 1);
                }
            });

            greenHealBlocks.forEach((block, index) => {
                block.update();
                block.draw();

                if (checkCollisionCircleRect(player, block) && block.size > 0) {
                    health = Math.min(100, health + 30);
                    greenHealBlocks.splice(index, 1);
                }
                if (block.size <= 0) {
                    greenHealBlocks.splice(index, 1);
                }
            });

            // 하드 모드 점수 업데이트 로직
            if (isHardMode) {
                const elapsedMinutes = (performance.now() - gameStartTime) / 60000;
                score = Math.floor(elapsedMinutes);
            }

            scoreDisplay.textContent = `점수: ${score}`;
            updateHealthBar();

            requestAnimationFrame(gameLoop);
        }

        // 충돌 감지 함수 (원과 사각형)
        function checkCollisionCircleRect(circle, rect) {
            const rectCenterX = rect.x + rect.size / 2;
            const rectCenterY = rect.y + rect.size / 2;

            const distX = Math.abs(circle.x - rectCenterX);
            const distY = Math.abs(circle.y - rectCenterY);

            const halfRectWidth = rect.size / 2;
            const halfRectHeight = rect.size / 2;

            if (distX > (halfRectWidth + circle.size / 2)) { return false; }
            if (distY > (halfRectHeight + circle.size / 2)) { return false; }

            if (distX <= (halfRectWidth)) { return true; }
            if (distY <= (halfRectHeight)) { return true; }

            const dx = distX - halfRectWidth;
            const dy = distY - halfRectHeight;
            return (dx * dx + dy * dy <= (circle.size / 2 * circle.size / 2));
        }

        // 키보드 이벤트 리스너 (움직임)
        document.addEventListener('keydown', (e) => {
            if (gameOver || stunned) return;
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W': player.dy = -player.speed; break;
                case 'ArrowDown': case 's': case 'S': player.dy = player.speed; break;
                case 'ArrowLeft': case 'a': case 'A': player.dx = -player.speed; break;
                case 'ArrowRight': case 'd': case 'D': player.dx = player.speed; break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameOver || stunned) return;
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W': case 'ArrowDown': case 's': case 'S': player.dy = 0; break;
                case 'ArrowLeft': case 'a': case 'A': case 'ArrowRight': case 'd': case 'D': player.dx = 0; break;
            }
        });

        // 마우스 드래그 이벤트 (플레이어 움직임)
        canvas.addEventListener('mousedown', (e) => {
            if (gameOver || stunned) return;
            isDragging = true;
            const rect = canvas.getBoundingClientRect();
            lastMouseX = e.clientX - rect.left;
            lastMouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (gameOver || !isDragging || stunned) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const currentMouseX = e.clientX - rect.left;
            const currentMouseY = e.clientY - rect.top;

            const deltaX = currentMouseX - lastMouseX;
            const deltaY = currentMouseY - lastMouseY;

            player.x += deltaX;
            player.y += deltaY;

            lastMouseX = currentMouseX;
            lastMouseY = currentMouseY;
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            player.dx = 0;
            player.dy = 0;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            player.dx = 0;
            player.dy = 0;
        });

        // 터치 드래그 이벤트 (모바일 지원)
        canvas.addEventListener('touchstart', (e) => {
            if (gameOver || stunned) return;
            e.preventDefault();
            isDragging = true;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            lastTouchX = touch.clientX - rect.left;
            lastTouchY = touch.clientY - rect.top;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (gameOver || !isDragging || stunned) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const currentTouchX = touch.clientX - rect.left;
            const currentTouchY = touch.clientY - rect.top;

            const deltaX = currentTouchX - lastTouchX;
            const deltaY = currentTouchY - lastTouchY;

            player.x += deltaX;
            player.y += deltaY;

            lastTouchX = currentTouchX;
            lastTouchY = currentTouchY;
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
            player.dx = 0;
            player.dy = 0;
        });

        canvas.addEventListener('touchcancel', () => {
            isDragging = false;
            player.dx = 0;
            player.dy = 0;
        });

        // 다시 시작 버튼 길게 누르기 이벤트 (비밀 무적용)
        restartButton.addEventListener('mousedown', (e) => {
            if (gameOver) {
                restartButtonHoldStartTime = performance.now();
                if (restartButtonHoldTimer) clearTimeout(restartButtonHoldTimer);
                restartButtonHoldTimer = setTimeout(() => {
                    secretInvincibilitySection.style.display = 'flex';
                    playInvincibleButton.style.display = 'none'; // 비밀번호 섹션 표시 시 모든 버튼 숨김
                    playAdminButton.style.display = 'none';
                    playHardModeButton.style.display = 'none';
                    passwordInput.focus();
                    restartButtonHoldTimer = null;
                }, SECRET_INVINCIBILITY_HOLD_TIME);
            }
        });

        restartButton.addEventListener('mouseup', (e) => {
            if (gameOver) {
                if (restartButtonHoldTimer) {
                    clearTimeout(restartButtonHoldTimer);
                    const holdDuration = performance.now() - restartButtonHoldStartTime;
                    if (holdDuration < SECRET_INVINCIBILITY_HOLD_TIME) {
                        init(); // 일반 다시 시작
                        gameLoop();
                    }
                    restartButtonHoldTimer = null;
                }
            }
        });

        // 다시 시작 버튼 모바일 터치 이벤트 (길게 누르기)
        restartButton.addEventListener('touchstart', (e) => {
            if (gameOver) {
                e.preventDefault();
                restartButtonHoldStartTime = performance.now();
                if (restartButtonHoldTimer) clearTimeout(restartButtonHoldTimer);
                restartButtonHoldTimer = setTimeout(() => {
                    secretInvincibilitySection.style.display = 'flex';
                    playInvincibleButton.style.display = 'none'; // 비밀번호 섹션 표시 시 모든 버튼 숨김
                    playAdminButton.style.display = 'none';
                    playHardModeButton.style.display = 'none';
                    passwordInput.focus();
                    restartButtonHoldTimer = null;
                }, SECRET_INVINCIBILITY_HOLD_TIME);
            }
        }, { passive: false });

        restartButton.addEventListener('touchend', (e) => {
            if (gameOver) {
                if (restartButtonHoldTimer) {
                    clearTimeout(restartButtonHoldTimer);
                    const holdDuration = performance.now() - restartButtonHoldStartTime;
                    if (holdDuration < SECRET_INVINCIBILITY_HOLD_TIME) {
                        init(); // 일반 다시 시작
                        gameLoop();
                    }
                    restartButtonHoldTimer = null;
                }
            }
        });

        // 비밀번호 제출 이벤트
        submitPasswordButton.addEventListener('click', () => {
            // 하드 모드에서는 비밀번호 기능이 작동하지 않음
            if (isHardMode) {
                passwordMessage.style.color = 'yellow';
                passwordMessage.textContent = '하드모드에서는 비밀번호가 작동하지 않습니다!';
                passwordInput.value = '';
                return;
            }

            const enteredPassword = passwordInput.value;
            const adminPassword = '성기없찐이~~!'; // 관리자 비밀번호
            const invinciblePassword = '김하진바보이지우천재!'; // 무적 전용 비밀번호

            if (enteredPassword === adminPassword) {
                passwordMessage.style.color = 'lime';
                passwordMessage.textContent = '비밀번호 확인! 관리자 모드로 플레이 버튼을 누르세요!';
                secretInvincibilitySection.style.display = 'none'; // 비밀번호 섹션 숨김
                playAdminButton.style.display = 'block'; // 관리자 버튼 표시
                playInvincibleButton.style.display = 'none'; // 다른 버튼 숨김
                playHardModeButton.style.display = 'none'; // 하드 모드 버튼 숨김
                passwordInput.value = ''; // 비밀번호 입력 필드 지우기
            } else if (enteredPassword === invinciblePassword) {
                passwordMessage.style.color = 'lime';
                passwordMessage.textContent = '비밀번호 확인! 무적으로 플레이 버튼을 누르세요!';
                secretInvincibilitySection.style.display = 'none'; // 비밀번호 섹션 숨김
                playInvincibleButton.style.display = 'block'; // 무적 버튼 표시
                playAdminButton.style.display = 'none'; // 다른 버튼 숨김
                playHardModeButton.style.display = 'none'; // 하드 모드 버튼 숨김
                passwordInput.value = ''; // 비밀번호 입력 필드 지우기
            } else {
                passwordMessage.style.color = 'red';
                passwordMessage.textContent = '비밀번호가 틀렸습니다!';
                passwordInput.value = '';
            }
        });

        // "무적으로 플레이" 버튼 이벤트
        playInvincibleButton.addEventListener('click', () => {
            startGameWithInvincibilityOnly();
        });

        // "관리자 모드로 플레이" 버튼 이벤트
        playAdminButton.addEventListener('click', () => {
            startGameWithAdminMode();
        });

        // "하드모드!" 버튼 (관리자 패널 내)
        hardModeButton.addEventListener('click', () => {
            if (isAdminMode) { // 관리자 모드에서만 접근 가능
                lastActivatedMode = 'hard'; // 하드 모드로 전환
                gameOver = true; // 현재 게임 중지
                // gameLoop()가 다음 프레임에서 gameOver를 감지하고 화면을 업데이트할 것임
            }
        });

        // "하드모드로 플레이" 버튼 (게임 오버 화면)
        playHardModeButton.addEventListener('click', () => {
            startGameInHardMode();
        });

        // 관리자 패널 버튼 이벤트 리스너
        addScoreButton.addEventListener('click', () => {
            if (isAdminMode) {
                score += 10000;
                scoreDisplay.textContent = `점수: ${score}`;
            }
        });

        toggleScoreBuffButton.addEventListener('click', () => {
            if (isAdminMode) {
                fastScoreMode = !fastScoreMode;
                toggleScoreBuffButton.textContent = fastScoreMode ? '점수 버프 해제' : '점수 오르기 버프';
            }
        });

        toggleInvincibilityButton.addEventListener('click', () => {
            if (isAdminMode) { // 관리자 모드에서만 토글 허용
                playerInvincible = !playerInvincible;
                toggleInvincibilityButton.textContent = playerInvincible ? '무적 해제' : '무적 토글';
            }
        });

        resetGameButton.addEventListener('click', () => {
            if (isAdminMode) {
                startGameWithAdminMode(); // 관리자 모드로 다시 시작
            }
        });

        increaseSpeedButton.addEventListener('click', () => {
            if (isAdminMode) {
                player.speed += 1;
                console.log(`플레이어 스피드 증가: ${player.speed}`); // 디버깅을 위한 콘솔 로그
            }
        });

        decreaseSpeedButton.addEventListener('click', () => {
            if (isAdminMode) {
                player.speed = Math.max(1, player.speed - 1);
                console.log(`플레이어 스피드 감소: ${player.speed}`); // 디버깅을 위한 콘솔 로그
            }
        });

        increaseSizeButton.addEventListener('click', () => {
            if (isAdminMode) {
                player.size += 5;
            }
        });

        decreaseSizeButton.addEventListener('click', () => {
            if (isAdminMode) {
                player.size = Math.max(5, player.size - 5);
            }
        });

        // 적 생성 타이머
        setInterval(() => {
            if (gameOver) return; // 게임 오버 시 중지

            const elapsedTime = performance.now() - gameStartTime;

            let redBlockChance = 0.6;
            let guidedBlockChance = 0.3;
            let purpleBlockChance = 0.2;
            let orangePanelChance = 0.1;
            let laserChance = 0.05;

            // 하드 모드에서 장애물 생성 확률 증가
            if (isHardMode) {
                redBlockChance = 0.9; // 더 자주
                guidedBlockChance = 0.5;
                purpleBlockChance = 0.4;
                orangePanelChance = 0.2;
                laserChance = 0.1; // 레이저 더 자주
            }

            // 초기 무적 시간 이후 또는 치트/하드 모드에서는 즉시 적 생성 시작
            if (elapsedTime >= INVINCIBILITY_DURATION || isHardMode || isAdminMode || isInvincibleOnlyMode) { 
                if (Math.random() < redBlockChance) {
                    redBlocks.push(new RedBlock());
                    if (isHardMode && Math.random() < 0.3) redBlocks.push(new RedBlock()); // 하드 모드에서 추가 블록
                }

                if (Math.random() < guidedBlockChance) {
                    guidedBlocks.push(new GuidedBlock(player));
                    if (isHardMode && Math.random() < 0.2) guidedBlocks.push(new GuidedBlock(player)); // 하드 모드에서 추가 블록
                }

                if (Math.random() < purpleBlockChance) {
                    purpleBlocks.push(new PurpleBlock());
                }

                if (Math.random() < orangePanelChance) {
                    orangePanels.push(new OrangePanel());
                }

                if (Math.random() < 0.05 && health < 100) { // 녹색 회복 블록은 덜 자주 생성
                    greenHealBlocks.push(new GreenHealBlock());
                }
            }

            if (elapsedTime >= LASER_START_DELAY && lasers.length < MAX_LASERS) {
                if (Math.random() < laserChance) {
                    lasers.push(new Laser());
                }
            }

        }, 1000);

        // 캔버스 크기 조절 및 반응형
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const aspectRatio = 800 / 600;

            let newWidth = window.innerWidth * 0.9;
            let newHeight = window.innerHeight * 0.9;

            if (newWidth / newHeight > aspectRatio) {
                newWidth = newHeight * aspectRatio;
            } else {
                newHeight = newWidth / aspectRatio;
            }

            canvas.width = newWidth;
            canvas.height = newHeight;

            if (player) {
                player.x = canvas.width / 2;
                player.y = canvas.height / 2;
            }
        }

        // 윈도우 로드 시 초기 설정
        window.addEventListener('load', async () => {
            resizeCanvas();
            init();
            gameLoop();
        });
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
