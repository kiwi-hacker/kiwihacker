<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brick Breaker</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      background: #faf8ef;
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;11
      justify-content: center;
      min-height: 100vh;
    }

    canvas {
      border: 2px solid black;
      margin: 0 auto;
      display: block;
      background-color: #f0f0f0;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      width: 100%; /* Make canvas fluid */
      max-width: 720px; /* Max width for desktop */
      height: auto; /* Maintain aspect ratio */
    }

    .game-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 20px;
      justify-content: center;
      width: 100%;
      max-width: 720px;
    }

    button {
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1.1em;
      cursor: pointer;
      background-color: #5ba7f4;
      color: white;
      border: none;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: background-color 0.3s ease, transform 0.2s ease;
      flex-grow: 1; /* Allow buttons to grow */
      max-width: 200px; /* Limit button width */
    }

    button:hover {
      background-color: #4a90e2;
      transform: translateY(-2px);
    }

    button:active {
      background-color: #3a7bd5;
      transform: translateY(0);
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      text-align: center;
      max-width: 90%;
      width: 400px;
      position: relative;
    }

    .modal-content h3 {
      font-size: 1.8em;
      margin-bottom: 20px;
      color: #333;
    }

    .modal-content input[type="password"],
    .modal-content input[type="text"] {
      width: calc(100% - 20px);
      padding: 12px;
      margin-bottom: 20px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 1em;
      box-sizing: border-box;
    }

    .modal-content .modal-buttons button {
      margin: 0 10px;
      padding: 10px 20px;
      font-size: 1em;
    }

    .admin-panel-options button {
      width: 100%;
      margin-bottom: 10px;
    }

    .close-button {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      font-size: 1.5em;
      color: #aaa;
      cursor: pointer;
      padding: 5px;
      border-radius: 50%;
      transition: color 0.2s ease;
    }

    .close-button:hover {
      color: #666;
    }

    .message-box {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      z-index: 1001;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      pointer-events: none; /* Allows clicks to pass through when hidden */
    }

    .message-box.show {
      opacity: 1;
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>
  <div class="game-controls">
    <button onclick="gameManager.downBalls()">공 내리기</button>
    <button id="breakItemButton" onclick="gameManager.activateBreakItem()">블럭 10개 부수기 (남은 횟수: <span id="breakItemCount">3</span>)</button>
    <button id="restartButton">다시 시작</button>
  </div>

  <!-- Password Input Modal -->
  <div id="passwordModal" class="modal-overlay hidden">
    <div class="modal-content">
      <button class="close-button" onclick="gameManager.hidePasswordPrompt()">&times;</button>
      <h3>비밀번호를 입력하세요</h3>
      <input type="password" id="passwordInput" placeholder="비밀번호">
      <div class="modal-buttons">
        <button onclick="gameManager.checkPassword()">확인</button>
        <button onclick="gameManager.hidePasswordPrompt()">취소</button>
      </div>
      <p id="passwordError" class="text-red-500 mt-2 hidden">비밀번호가 틀렸습니다.</p>
    </div>
  </div>

  <!-- Admin Panel Modal -->
  <div id="adminPanelModal" class="modal-overlay hidden">
    <div class="modal-content">
      <button class="close-button" onclick="gameManager.hideAdminPanel()">&times;</button>
      <h3>관리자 패널</h3>
      <div class="admin-panel-options">
        <button onclick="gameManager.fullGameReset()">게임 초기화 (최고기록 포함)</button>
        <button onclick="gameManager.resetHighScore()">최고 점수 초기화</button>
        <button onclick="gameManager.addBallsAdmin(5)">공 5개 추가</button>
        <button onclick="gameManager.skipLevel()">레벨 건너뛰기</button>
        <button onclick="gameManager.giveBreakItemAdmin()">블럭 부수기 아이템 3개 추가</button>
      </div>
    </div>
  </div>

  <!-- Message Box -->
  <div id="messageBox" class="message-box"></div>

  <script>
    /**
     * Utility Functions
     **/
    function randomInt(...args) {
      if (args.length === 1) {
        const [n] = args;
        return Math.ceil(Math.random() * n);
      }

      if (args.length === 2) {
        const [start, end] = args;

        if (start > end) throw Error("시작값이 끝값보다 큼");

        return Math.ceil(Math.random() * (end - start)) + start;
      }
    }

    function random(...args) {
      if (args.length === 1) {
        const [n] = args;
        return Math.random() * n;
      }

      if (args.length === 2) {
        const [start, end] = args;

        if (start > end) throw Error("시작값이 끝값보다 큼");

        return Math.random() * (end - start) + start;
      }
    }

    const range = function (n, m) {
      if (arguments.length === 1)
        return Array.from({ length: n }).map((_, i) => i);

      if (arguments.length === 2) {
        if (n === m) return [n];
        else if (n < m) {
          return Array.from({ length: m - n + 1 }).map((_, i) => i + n);
        } else {
          return Array.from({ length: n - m + 1 }).map(
            (_, i) => m - i + (n - m)
          );
        }
      }
    };

    function normalize(n) {
      return n < 0 ? -1 : n > 0 ? 1 : 0;
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function between(v, min, max) {
      return min <= v && v <= max;
    }

    const delay = (n) => new Promise((r) => setTimeout(r, n));

    /**
     * Message Box for user feedback
     */
    function showMessageBox(message, duration = 2000) {
      const messageBox = document.getElementById('messageBox');
      messageBox.textContent = message;
      messageBox.classList.add('show');
      setTimeout(() => {
        messageBox.classList.remove('show');
      }, duration);
    }
  </script>

  <script>
    /**
     * Vector Library
     **/
    class Vector {
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }

      add(v) {
        this.x += v.x;
        this.y += v.y;
      }

      sub(v) {
        this.x -= v.x;
        this.y -= v.y;
      }

      mult(n) {
        this.x *= n;
        this.y *= n;
      }

      mag() {
        return Math.sqrt(this.x * this.x + this.y * this.y); // Corrected magnitude calculation
      }

      get() {
        return new Vector(this.x, this.y);
      }

      normalize() {
        const m = this.mag();
        if (m > 0) {
          this.div(m);
        }
      }

      copy() {
        return new Vector(this.x, this.y);
      }

      div(n) {
        this.x /= n;
        this.y /= n;
      }
    }

    Vector.mult = (v, n) => new Vector(v.x * n, v.y * n);

    Vector.div = (v, n) => new Vector(v.x / n, v.y / n);
  </script>

  <script>
    /**
     * Canvas Library
     **/
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const width = 720; // Fixed width for game logic
    const height = 800; // Fixed height for game logic
    const uiOffsetY = 80;

    canvas.width = width;
    canvas.height = height;

    // Adjust canvas display size for responsiveness
    function resizeCanvas() {
      const gameContainer = document.querySelector('.game-controls').parentNode; // Parent of game-controls is body
      const availableWidth = gameContainer.clientWidth * 0.9; // 90% of available width
      const maxCanvasWidth = 720; // Max width for desktop
      
      let newCanvasWidth = Math.min(availableWidth, maxCanvasWidth);
      let newCanvasHeight = (newCanvasWidth / width) * height; // Maintain aspect ratio

      canvas.style.width = `${newCanvasWidth}px`;
      canvas.style.height = `${newCanvasHeight}px`;

      // Store current scaling factor for mouse events
      canvas.currentScaleX = newCanvasWidth / width;
      canvas.currentScaleY = newCanvasHeight / height;
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', resizeCanvas); // Initial resize on load

    function line(x1, y1, x2, y2, color = "#000") {
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function dashLine(x1, y1, x2, y2) {
      ctx.beginPath();
      ctx.setLineDash([5, 15]);
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function rect(x, y, w, h) {
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.strokeStyle = "#000";
      ctx.stroke();
      ctx.closePath();
    }

    function fillRect(x, y, w, h, color = "#171717") {
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.fillRect(x, y, w, h);
      ctx.stroke();
      ctx.closePath();
      ctx.restore();
    }

    function circle(x, y, r, color = "#000") {
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.lineWidth = 3;
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
      ctx.restore();
    }

    function clear() {
      ctx.clearRect(0, 0, width, height);
    }

    function shuffle(arr) {
      return arr.sort(() => Math.random() - 0.5);
    }
  </script>

  <script>
    /**
     * User Code
     **/
    const POWER = 0.3;

    const Mouse = { position: new Vector(0, 0) };

    class BallLine {
      constructor() { }

      display(state) {
        if (!state.ballMoving && !state.brickMoving && state.ballPos && !state.isBreakItemActive) {
          dashLine(
            state.ballPos.x,
            state.ballPos.y,
            Mouse.position.x,
            Math.min(Mouse.position.y, 720)
          );
        }
      }
    }

    class Ball {
      constructor(mass, x, y) {
        this.position = new Vector(x, y);
        this.velocity = new Vector(0, 0);
        this.acceleration = new Vector(0, 0);
        this.mass = mass;
        this.r = this.mass * 8;
        this.showDirection = true;
      }

      setOnStop(f) {
        this.onStop = f;
      }

      applyForce(force) {
        const f = Vector.div(force, this.mass);
        this.acceleration.add(f);
      }

      update() {
        this.velocity.add(this.acceleration);
        this.position.add(this.velocity);

        this.acceleration.mult(0);
      }

      move(direction) {
        if (direction === "right") this.applyForce(new Vector(20, 0));
        else if (direction === "left") this.applyForce(new Vector(-20, 0));
      }

      stop() {
        this.velocity = new Vector(0, 0);
        this.showDirection = true;
        this.onStop(this);
        this.downing = false;
      }

      down() {
        this.downing = true;
        this.velocity = new Vector(0, 30);
      }

      shoot(mousePos) {
        this.showDirection = false;
        const force = this.calcBallVelocity(this.angle(mousePos));
        this.applyForce(force);
      }

      calcBallVelocity(angle) {
        return new Vector(
          100 * Math.cos(angle) * POWER,
          100 * Math.sin(angle) * POWER
        );
      }

      angle(mousePos) {
        const opposite = mousePos.y - this.position.y;
        const adjacent = mousePos.x - this.position.x;
        const angle = Math.atan2(opposite, adjacent);

        return angle;
      }

      display() {
        circle(this.position.x, this.position.y, this.r, "#5ba7f4");
      }

      collideWith(brick) {
        if (this.downing) return false;

        const { x, y } = this.position;
        const r = this.r;

        const closestX = clamp(x, brick.x, brick.x + brick.w);
        const closestY = clamp(y, brick.y, brick.y + brick.h);

        const distanceX = x - closestX;
        const distanceY = y - closestY;
        const distanceSquared = distanceX * distanceX + distanceY * distanceY;

        const collided = distanceSquared < r * r;

        if (!collided) return false;

        // Determine which side of the brick was hit
        if (
          closestY === brick.y &&
          between(closestX, brick.x - r + 3, brick.x + brick.w + r - 3)
        ) {
          // Hit top side
          this.velocity.y *= -1;
          this.position.y = closestY - r;
        } else if (
          closestY === brick.y + brick.h &&
          between(closestX, brick.x - r + 3, brick.x + brick.w + r - 3)
        ) {
          // Hit bottom side
          this.velocity.y *= -1;
          this.position.y = closestY + r;
        } else if (
          closestX === brick.x &&
          between(closestY, brick.y - r + 3, brick.y + brick.h + r - 3)
        ) {
          // Hit left side
          this.velocity.x *= -1;
          this.position.x = closestX - r;
        } else if (
          closestX === brick.x + brick.w &&
          between(closestY, brick.y - r + 3, brick.y + brick.h + r - 3)
        ) {
          // Hit right side
          this.velocity.x *= -1;
          this.position.x = closestX + r;
        } else {
          // Corner hit, reverse both axes (simple approximation)
          this.velocity.x *= -1;
          this.velocity.y *= -1;
        }

        return true;
      }

      collideWithBonusBall(bonusBall) {
        if (this.downing) return false;

        const x = this.position.x - bonusBall.x;
        const y = this.position.y - bonusBall.y;
        const r = this.r;
        const collided = 2 * r >= Math.sqrt(x * x + y * y);

        return collided;
      }

      checkEdges() {
        if (this.position.x + this.r > width) {
          this.position.x = width - this.r;
          this.velocity.x *= -1;
        } else if (this.position.x - this.r < 0) {
          this.position.x = this.r;
          this.velocity.x *= -1;
        }

        if (this.position.y + this.r > height - 100) {
          this.velocity.y *= -1;
          this.position.y = height - 100 - this.r;
          this.stop();
        } else if (this.position.y - this.r < uiOffsetY) {
          this.velocity.y *= -1;
          this.position.y = uiOffsetY + this.r;
        }
      }
    }

    class Brick {
      constructor(n, x, y) {
        this.n = n;
        this.start = n;

        this.x = x * 120;
        this.y = y * 80 + uiOffsetY;
        this.w = 110;
        this.h = 70;
      }

      shouldMoveDown(state) {
        return this.y < 80 * (state.level - this.start + 1) + uiOffsetY;
      }

      update(state) {
        if (this.shouldMoveDown(state)) {
          this.y = Math.min(
            this.y + 10,
            80 * (state.level - this.start + 1) + uiOffsetY
          );
        }
      }

      color(level) {
        const percentage = ((level - this.n) / level) * 30;
        return `hsl(${percentage}, ${100 - percentage}%, 63%)`;
      }

      display(state) {
        fillRect(this.x, this.y, this.w, this.h, this.color(state.level));
        ctx.fillStyle = "black";
        ctx.font = "20px Arial";
        ctx.fillText(
          this.n,
          this.x + this.w / 2 - (this.n < 10 ? 8 : 12), // Adjust text position for double digits
          this.y + this.h / 2 + 5
        );
      }

      hit(damage = 1) {
        this.n -= damage;
      }

      get broken() {
        return this.n <= 0;
      }

      get hitBottom() {
        return this.y >= height - uiOffsetY - 80;
      }
    }

    class BrickParticle {
      constructor(n, x, y) {
        const i = n % 5;
        const j = ~~(n / 4);

        this.w = 22;
        this.h = 18;
        this.location = new Vector(x + i * this.w, y + j * this.h);
        this.acceleration = new Vector(0, 0);
        this.velocity = new Vector(
          i > 2
            ? random(0, 0.5)
            : i === 2
              ? random(-0.5, 0.5)
              : random(-0.5, 0),
          random(1, 3)
        );
        this.lifespan = 255;
      }

      update() {
        this.velocity.add(this.acceleration);
        this.location.add(this.velocity);
        this.lifespan -= 4;
      }

      display() {
        fillRect(
          this.location.x,
          this.location.y,
          22,
          18,
          `hsla(30, 70%, 63%, ${this.lifespan / 255})`
        );
      }

      run() {
        this.update();
        this.display();
      }

      get isDead() {
        return this.lifespan < 0;
      }
    }

    class BrickParticleSystem {
      constructor(x, y) {
        this.origin = new Vector(x, y);
        this.particles = range(20).map((n) => new BrickParticle(n, x, y));
      }

      addParticle() {
        this.particles.push(new BrickParticle(this.origin));
      }

      run() {
        this.particles.forEach((particle) => particle.run());
      }

      get isDead() {
        return !this.particles.length || this.particles[0].isDead;
      }
    }

    class BrickParticleSystems {
      constructor() {
        this.particleSystems = [];
      }

      addParticleSystem(...bricks) {
        const newPs = bricks.map(({ x, y }) => new BrickParticleSystem(x, y));
        this.particleSystems.push(...newPs);
      }

      run() {
        this.particleSystems = this.particleSystems.filter(
          (ps) => !ps.isDead
        );
        this.particleSystems.forEach((ps) => ps.run());
      }
    }

    class BonusBall {
      constructor(n, x, y) {
        this.start = n;
        this.r = 16;
        this.x = x * 120 + 56;
        this.y = y * 80 + 36 + uiOffsetY;
        this.hit = false;
      }

      moveDownLittle(state) {
        this.y = Math.min(
          this.y + 10,
          80 * (state.level - this.start + 1) + uiOffsetY + 40
        );
      }

      update(state) {
        if (this.hit) this.y = Math.min(this.y + 50, height - 100);
        else this.moveDownLittle(state);

        if (this.hit && this.y === height - 100 && state.brickMoving) {
          if (this.x < state.ballPos.x) {
            this.x = Math.min(this.x + 30, state.ballPos.x);
          } else {
            this.x = Math.max(this.x - 30, state.ballPos.x);
          }
        }
      }

      display() {
        circle(this.x, this.y, this.r, "#3dd462");
      }

      hitWithBall() {
        this.hit = true;
      }

      collideWith(ball) {
        const x = ball.position.x - this.x;
        const y = ball.position.y - this.y;
        const r = this.r;
        const collided = 2 * r >= Math.sqrt(x * x + y * y);

        if (collided) {
          this.hit = true;
        }
        return collided;
      }
    }

    class UI {
      constructor() { }

      display(state) {
        line(0, uiOffsetY, width, uiOffsetY);
        line(0, height - uiOffsetY, width, height - uiOffsetY);

        this.showBallCount(state);
        this.showScore(state);
      }

      showScore(state) {
        ctx.fillStyle = "black";
        ctx.font = "20px Arial";
        ctx.fillText(`현재 점수: ${state.level}`, 30, uiOffsetY / 2 + 7);
        ctx.fillText(
          `최고 점수: ${state.bestLevel}`,
          width - 150,
          uiOffsetY / 2 + 7
        );
      }

      showBallCount(state) {
        if (!state.ballMoving)
          ctx.fillText(
            `x${state.ballCount}`,
            state.ballPos.x - 10,
            height - 55
          );
      }

      gameOver() {
        fillRect(0, height / 2 - 100, width, 200, "rgba(0, 0, 0, 0.3)");
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.fillText("패배!", width / 2 - 40, height / 2 + 12);
        ctx.font = "20px Arial";
      }
    }

    class Balls {
      constructor(state) {
        this.balls = [];
        this.state = state; // Store state reference
        this.initializeBalls();
      }

      initializeBalls() {
        this.balls = range(this.state.ballCount).map(
          (i) => new Ball(2, this.state.ballPos.x, this.state.ballPos.y)
        );
        this.balls.forEach((ball) => ball.setOnStop(this.onBallStop.bind(this)));
      }

      onBallStop(ball) {
        if (!this.state.firstBallStop) {
          this.state.ballPos = ball.position.copy();
          this.state.firstBallStop = true;
        }

        ball.position.x = this.state.ballPos.x;
      }

      collideWithBricks(bricks) {
        bricks.bricks.forEach((brick) => {
          this.balls.forEach((ball) => {
            const collided = ball.collideWith(brick);
            if (collided) {
              brick.hit();
            }
          });
        });
      }

      collideWithBonusBall(bonusBalls) {
        this.balls.forEach((ball) => {
          bonusBalls.forEach((bonusBall) => {
            const collided = ball.collideWithBonusBall(bonusBall);
            if (collided) bonusBall.hitWithBall();
          });
        });
      }

      get allStopped() {
        return this.balls.every((ball) => ball.velocity.mag() === 0);
      }

      addBalls(n) {
        const currentBallCount = this.balls.length;
        const newBalls = range(n).map(
          (i) => new Ball(2, this.state.ballPos.x, this.state.ballPos.y)
        );
        newBalls.forEach((ball) => ball.setOnStop(this.onBallStop.bind(this)));
        this.balls.push(...newBalls);
        this.state.ballCount = this.balls.length; // Update state ballCount
      }

      async shoot(mousePos) {
        for (const ball of this.balls) {
          if (this.state.ballDowning) return;
          ball.shoot(mousePos);
          await delay(Math.max(50 - ~~(this.state.ballCount / 10), 10));
        }
      }

      display() {
        this.balls.forEach((ball) => {
          ball.update();
          ball.checkEdges();
          ball.display();
        });
      }

      down() {
        this.balls.forEach((ball) => ball.down());
      }
    }

    class Bricks {
      constructor() {
        this.bricks = [];
        this.particleSystems = new BrickParticleSystems();
      }

      addBricks(state, newBrickIndeces) {
        const newBricks = newBrickIndeces.map(
          (i) => new Brick(state.level, i, 0)
        );
        this.bricks.push(...newBricks);
      }

      display(state) {
        this.bricks.forEach((brick) => {
          brick.update(state);
          brick.display(state);
        });

        this.particleSystems.run();
      }

      break() {
        const brokenBricks = this.bricks.filter((brick) => brick.broken);
        this.particleSystems.addParticleSystem(...brokenBricks);

        this.bricks = this.bricks.filter((brick) => !brick.broken);
      }

      shouldSlideDown(state) {
        return this.bricks.some(brick => brick.shouldMoveDown(state)); // Check if any brick needs to move down
      }

      get hitBottom() {
        return this.bricks.some(brick => brick.hitBottom); // Check if any brick hit bottom
      }

      getBrickAt(x, y) {
        // Find the brick that contains the given coordinates
        return this.bricks.find(brick =>
          x >= brick.x && x <= brick.x + brick.w &&
          y >= brick.y && y <= brick.y + brick.h
        );
      }
    }

    class BonusBalls {
      constructor() {
        this.bonusBalls = [];
      }

      addBonusBalls(state, newBonusBallIndex) {
        if (newBonusBallIndex !== undefined && newBonusBallIndex !== null) {
          this.bonusBalls = [
            ...this.bonusBalls,
            new BonusBall(state.level, newBonusBallIndex, 0),
          ];
        }
      }

      display(state) {
        this.bonusBalls.forEach((bonusBall) => {
          bonusBall.update(state);
          bonusBall.display();
        });
      }

      collideWithBall(balls) {
        this.bonusBalls.forEach((bonusBall) =>
          balls.balls.forEach((ball) => bonusBall.collideWith(ball))
        );
      }

      removeHitBalls() {
        this.bonusBalls = this.bonusBalls.filter(
          (b) => !b.hit || b.y > height
        );
      }

      get hitBallCount() {
        return this.bonusBalls.filter((ball) => ball.hit).length;
      }
    }

    class LocalStorageManager {
      constructor() {
        this.bestScoreKey = "brickBestScore";
        this.storage = window.localStorage;
      }

      getBestScore() {
        return parseInt(this.storage.getItem(this.bestScoreKey) || '1', 10);
      }

      setBestScore(score) {
        this.storage.setItem(this.bestScoreKey, score);
      }

      setScore(score) {
        this.setBestScore(Math.max(score, this.getBestScore()));
      }
    }

    class GameManager {
      constructor() {
        this.scoreStorage = new LocalStorageManager();
        this.restartTimer = null;
        this.restartButton = document.getElementById('restartButton');
        this.breakItemButton = document.getElementById('breakItemButton');
        this.breakItemCountSpan = document.getElementById('breakItemCount');
        this.passwordModal = document.getElementById('passwordModal');
        this.passwordInput = document.getElementById('passwordInput');
        this.passwordError = document.getElementById('passwordError');
        this.adminPanelModal = document.getElementById('adminPanelModal');

        this.initGame();
        this.setupEventListeners();
      }

      initGame() {
        this.state = {
          ballPos: new Vector(width / 2, height - 100),
          ballMoving: false,
          ballCount: 1,
          ballDowning: false,
          brickMoving: false,
          firstBallStop: true,
          level: 1,
          over: false,
          isBreakItemActive: false,
          breakItemUsesLeft: 3,
          bestLevel: this.scoreStorage.getBestScore(), // Load best score from local storage
        };

        this.balls = new Balls(this.state); // Pass state to Balls constructor
        this.bricks = new Bricks();
        this.bonusBalls = new BonusBalls();
        this.ballLine = new BallLine();
        this.ui = new UI();

        this.addBallsAndBricks();
        this.updateBreakItemUI();
        // Ensure the game loop is running if not already
        if (!this.animationFrameId) {
            this.run();
        }
      }

      setupEventListeners() {
        canvas.addEventListener("click", (e) => this.handleCanvasClick(e));

        // Single click for immediate restart
        this.restartButton.addEventListener('click', (e) => {
            // Prevent long press from also triggering immediate restart
            if (!this.restartTimer) { 
                this.restartCurrentGame();
            }
        });

        // Long press for admin panel
        this.restartButton.addEventListener('mousedown', () => this.startRestartTimer());
        this.restartButton.addEventListener('mouseup', () => this.clearRestartTimer());
        this.restartButton.addEventListener('mouseleave', () => this.clearRestartTimer());
      }

      startRestartTimer() {
        this.clearRestartTimer(); // Ensure no multiple timers
        this.restartTimer = setTimeout(() => {
          this.showPasswordPrompt();
          this.restartTimer = null; // Clear timer after it fires
        }, 10000); // 10 seconds
      }

      clearRestartTimer() {
        if (this.restartTimer) {
          clearTimeout(this.restartTimer);
          this.restartTimer = null;
        }
      }

      showPasswordPrompt() {
        this.passwordInput.value = '';
        this.passwordError.classList.add('hidden');
        this.passwordModal.classList.remove('hidden');
      }

      hidePasswordPrompt() {
        this.passwordModal.classList.add('hidden');
      }

      checkPassword() {
        const password = this.passwordInput.value;
        const correctPassword = "바자다가사ㅛㅏㅕㅏㅑㅏㅐㅏㅔㅏ이지우천재~~~!";
        if (password === correctPassword) {
          this.hidePasswordPrompt();
          this.showAdminPanel();
        } else {
          this.passwordError.classList.remove('hidden');
        }
      }

      showAdminPanel() {
        this.adminPanelModal.classList.remove('hidden');
      }

      hideAdminPanel() {
        this.adminPanelModal.classList.add('hidden');
      }

      // Resets current game state, but keeps high score
      restartCurrentGame() {
        this.state.over = false; // Reset game over state
        this.initGame(); // Reinitialize all game components
        showMessageBox("게임이 다시 시작되었습니다!");
      }

      // Resets high score only
      resetHighScore() {
        this.scoreStorage.setBestScore(1); // Set to initial score
        this.state.bestLevel = 1;
        this.hideAdminPanel();
        showMessageBox("최고 점수가 초기화되었습니다!");
      }

      // Resets current game state AND high score
      fullGameReset() {
        this.resetHighScore(); // Reset high score first
        this.restartCurrentGame(); // Then restart the game
        this.hideAdminPanel();
        showMessageBox("게임이 완전히 초기화되었습니다!");
      }

      addBallsAdmin(count) {
        this.balls.addBalls(count);
        this.hideAdminPanel();
        showMessageBox(`${count}개의 공이 추가되었습니다!`);
      }

      skipLevel() {
        this.state.level += 1;
        this.scoreStorage.setScore(this.state.level);
        this.state.bestLevel = this.scoreStorage.getBestScore();
        this.bricks.bricks = []; // Clear existing bricks
        this.bonusBalls.bonusBalls = []; // Clear existing bonus balls
        this.addBallsAndBricks(); // Generate new bricks for the new level
        this.hideAdminPanel();
        showMessageBox(`레벨 ${this.state.level}로 건너뛰었습니다!`);
      }

      giveBreakItemAdmin() {
        this.state.breakItemUsesLeft = 3;
        this.updateBreakItemUI();
        this.hideAdminPanel();
        showMessageBox("블럭 부수기 아이템 3개가 충전되었습니다!");
      }

      addBallsAndBricks() {
        const bonusBallCount = this.bonusBalls.hitBallCount;
        const newBrickIndeces = shuffle(range(6)).slice(
          0,
          Math.random() > 0.9 ? randomInt(5) : randomInt(4)
        );
        // Ensure bonus ball doesn't spawn on a brick
        let newBonusBallIndex = shuffle(
          range(6).filter((i) => !newBrickIndeces.includes(i))
        )[0];
        // If all positions are taken by bricks, don't add a bonus ball this round
        if (newBrickIndeces.length === 6) {
          newBonusBallIndex = undefined;
        }

        this.balls.addBalls(bonusBallCount);
        this.bricks.addBricks(this.state, newBrickIndeces);
        this.bonusBalls.addBonusBalls(this.state, newBonusBallIndex);
      }

      handleCanvasClick(e) {
        // Calculate mouse position relative to the scaled canvas
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) / canvas.currentScaleX;
        const mouseY = (e.clientY - rect.top) / canvas.currentScaleY;

        Mouse.position = new Vector(mouseX, mouseY);

        if (this.state.isBreakItemActive) {
          this.handleBrickClick(mouseX, mouseY);
        } else {
          this.shootBalls(e);
        }
      }

      shootBalls(e) {
        if (
          this.state.ballMoving ||
          this.state.brickMoving ||
          this.state.over
        )
          return;

        this.state.ballPos = null;
        this.state.ballMoving = true;
        this.state.ballDowning = false;
        this.state.firstBallStop = false;

        const { x, y } = Mouse.position;
        this.balls.shoot({ x, y: Math.min(y, 720) });
      }

      activateBreakItem() {
        if (this.state.over) {
          showMessageBox("게임 오버 상태에서는 사용할 수 없습니다.");
          return;
        }
        if (this.state.ballMoving || this.state.brickMoving) {
          showMessageBox("공이 움직이거나 블럭이 내려오는 중에는 사용할 수 없습니다.");
          return;
        }
        if (this.state.breakItemUsesLeft <= 0) {
          showMessageBox("블럭 부수기 아이템을 모두 사용했습니다.");
          return;
        }
        this.state.isBreakItemActive = true;
        showMessageBox("부술 블럭을 터치하세요!");
        // Optional: Change cursor style to indicate active item
        canvas.style.cursor = 'crosshair';
      }

      handleBrickClick(x, y) {
        if (!this.state.isBreakItemActive) return;

        const clickedBrick = this.bricks.getBrickAt(x, y);

        if (clickedBrick) {
          clickedBrick.hit(10); // Reduce brick's n by 10
          this.bricks.break(); // Check for broken bricks and create particles
          this.state.breakItemUsesLeft--;
          this.updateBreakItemUI();
          showMessageBox(`블럭을 ${10}만큼 부쉈습니다! 남은 횟수: ${this.state.breakItemUsesLeft}`);
        } else {
          showMessageBox("블럭이 아닌 곳을 클릭했습니다.");
        }

        this.state.isBreakItemActive = false;
        canvas.style.cursor = 'default'; // Reset cursor
      }

      updateBreakItemUI() {
        this.breakItemCountSpan.textContent = this.state.breakItemUsesLeft;
        this.breakItemButton.disabled = this.state.breakItemUsesLeft <= 0;
      }

      checkCollision() {
        this.balls.collideWithBricks(this.bricks);
        this.bonusBalls.collideWithBall(this.balls);
        this.bricks.break();
      }

      draw() {
        clear();
        this.ballLine.display(this.state);
        this.balls.display();
        this.bricks.display(this.state);
        this.bonusBalls.display(this.state);
        this.ui.display(this.state);
      }

      run() {
        // Clear any previous animation frame request to prevent multiple loops
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
        }

        this.animationFrameId = window.requestAnimationFrame(() => this.run());

        this.draw();
        this.checkCollision();

        if (this.state.ballMoving && this.balls.allStopped) {
          this.state.ballMoving = false;
          this.state.brickMoving = true;

          this.state.level += 1;
          this.scoreStorage.setScore(this.state.level);
          this.state.bestLevel = this.scoreStorage.getBestScore();

          this.addBallsAndBricks();
        }

        if (this.state.brickMoving) {
          if (!this.bricks.shouldSlideDown(this.state)) {
            this.state.brickMoving = false;
            this.bonusBalls.removeHitBalls();
          }
        }

        if (this.bricks.hitBottom) {
          this.ui.gameOver();
          this.state.over = true;
          cancelAnimationFrame(this.animationFrameId); // Stop the game loop on game over
          this.animationFrameId = null;
        }
      }

      downBalls() {
        // Allow 'downBalls' if balls are moving and game is not over or brick moving
        if (this.state.over || this.state.brickMoving || !this.state.ballMoving) {
          showMessageBox("현재 공을 내릴 수 없습니다.");
          return;
        }
        this.state.ballDowning = true;
        this.balls.down();
      }
    }

    // Initialize the game manager
    const gameManager = new GameManager();
    // The game loop is now started within initGame and managed by animationFrameId
  </script>
</body>

</html>