<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>쿠나이 마스터: 그림자 속의 과녁</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Malgun Gothic', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            text-align: center;
        }
        h1 {
            color: #e74c3c;
            text-shadow: 0 0 10px #e74c3c;
            margin-bottom: 10px;
        }
        #game-container {
            border: 3px solid #c0392b;
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
            position: relative;
        }
        canvas {
            display: block;
            background: url('https://www.toptal.com/designers/subtlepatterns/uploads/dark-denim.png');
            cursor: none; /* 기본 마우스 커서 숨기기 */
        }
        #ui-container {
            display: flex;
            justify-content: space-around;
            width: 800px;
            padding: 15px 0;
            background-color: #2c2c2c;
            border-radius: 0 0 10px 10px;
            border: 3px solid #c0392b;
            border-top: none;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .info {
            font-size: 1.2em;
            font-weight: bold;
        }
        .info span {
            color: #e74c3c;
            font-size: 1.4em;
        }
        #mode-selection {
            margin-top: 20px;
        }
        button {
            background-color: #e74c3c;
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            margin: 0 10px;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 0 #c0392b;
        }
        button:hover {
            background-color: #c0392b;
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #c0392b;
        }
    </style>
</head>
<body>

    <h1>쿠나이 마스터: 그림자 속의 과녁</h1>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>
    <div id="ui-container">
        <div class="info">모드: <span id="modeDisplay">대기중</span></div>
        <div class="info">레벨: <span id="levelDisplay">1</span></div>
        <div class="info">점수: <span id="scoreDisplay">0</span></div>
    </div>
    <div id="mode-selection">
        <button id="trainingModeBtn">수련 모드</button>
        <button id="freeModeBtn">자유 모드</button>
        <button id="hardModeBtn">그림자 모드</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const modeDisplay = document.getElementById('modeDisplay');
        
        // Game state
        let score = 0;
        let level = 1;
        let gameMode = ''; // 'training', 'free', 'hard'
        let targets = [];
        let kunais = [];
        let particles = [];
        let crosshair = { x: 0, y: 0 };
        let gameRunning = false;

        // Images
        const crosshairImg = new Image();
        crosshairImg.src = 'https://i.imgur.com/gUPP5zP.png'; // 크로스헤어 이미지
        const targetImg = new Image();
        targetImg.src = 'https://i.imgur.com/r5L2s17.png'; // 과녁 이미지
        const kunaiImg = new Image();
        kunaiImg.src = 'https://i.imgur.com/15kS9Yg.png'; // 쿠나이 이미지

        // --- Classes ---

        class Target {
            constructor(x, y, radius, speedX, speedY, isHard = false) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.speedX = speedX;
                this.speedY = speedY;
                this.isHard = isHard;
                this.teleportInterval = 2000 + Math.random() * 2000; // 2~4초마다 텔레포트
                this.lastTeleportTime = Date.now();
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                // Wall collision
                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) this.speedX *= -1;
                if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) this.speedY *= -1;

                // Hard mode teleport
                if (this.isHard && Date.now() - this.lastTeleportTime > this.teleportInterval) {
                    this.teleport();
                }
            }
            
            teleport() {
                this.x = this.radius + Math.random() * (canvas.width - this.radius * 2);
                this.y = this.radius + Math.random() * (canvas.height - this.radius * 2);
                this.lastTeleportTime = Date.now();
                this.teleportInterval = 2000 + Math.random() * 2000;
                // 텔레포트 후 파티클 효과
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(this.x, this.y, Math.random() * 3, '#7f8c8d'));
                }
            }

            draw() {
                ctx.drawImage(targetImg, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
            }
        }

        class Kunai {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 15;
                this.height = 40;
                this.speedY = -15; // 위로 날아가는 속도
            }
            
            update() {
                this.y += this.speedY;
            }

            draw() {
                ctx.drawImage(kunaiImg, this.x - this.width/2, this.y - this.height/2, this.width, this.height);
            }
        }

        class Particle {
             constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.alpha = 1;
                this.velocity = {
                    x: (Math.random() - 0.5) * 8,
                    y: (Math.random() - 0.5) * 8
                };
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.restore();
            }

            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= 0.02;
                this.draw();
            }
        }

        // --- Game Logic ---
        function startGame(mode) {
            gameMode = mode;
            score = 0;
            level = 1;
            targets = [];
            kunais = [];
            particles = [];
            gameRunning = true;
            modeDisplay.textContent = {
                training: '수련 모드',
                free: '자유 모드',
                hard: '그림자 모드'
            }[mode];
            
            setupTargetsForMode();
            gameLoop();
        }

        function setupTargetsForMode() {
            targets = []; // Clear existing targets
            if (gameMode === 'training') {
                spawnTarget();
            } else if (gameMode === 'free') {
                const numTargets = 2 + Math.floor(Math.random() * 5); // 2~6개
                for (let i = 0; i < numTargets; i++) {
                    spawnRandomTarget();
                }
            } else if (gameMode === 'hard') {
                 spawnTarget(true); // 1개의 텔레포트 타겟
            }
        }
        
        function spawnTarget(isHard = false) {
            const radius = isHard ? 20 : 30;
            const x = radius + Math.random() * (canvas.width - radius * 2);
            const y = radius + Math.random() * (canvas.height - radius * 2);
            const baseSpeed = gameMode === 'training' ? 1 + level * 0.2 : 4;
            const speedX = (Math.random() - 0.5) * baseSpeed;
            const speedY = (Math.random() - 0.5) * baseSpeed;
            targets.push(new Target(x, y, radius, speedX, speedY, isHard));
        }

        function spawnRandomTarget() {
             const radius = 15 + Math.random() * 25; // 15~40
             const x = radius + Math.random() * (canvas.width - radius * 2);
             const y = radius + Math.random() * (canvas.height - radius * 2);
             const speed = 2 + Math.random() * 5; // 2~7
             const angle = Math.random() * Math.PI * 2;
             const speedX = Math.cos(angle) * speed;
             const speedY = Math.sin(angle) * speed;
             targets.push(new Target(x, y, radius, speedX, speedY));
        }

        function levelUp() {
            if (gameMode !== 'training' || level >= 50) return;

            const requiredScore = level * 150;
            if (score >= requiredScore) {
                level++;
                if (targets.length < 5) { // 최대 5개까지 타겟 추가
                    spawnTarget();
                }
                // 모든 타겟 속도 증가
                targets.forEach(target => {
                    target.speedX *= 1.1;
                    target.speedY *= 1.1;
                });
            }
        }
        
        function updateUI() {
            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
        }

        function gameLoop() {
            if (!gameRunning) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update & Draw Kunais
            kunais.forEach((kunai, index) => {
                kunai.update();
                kunai.draw();
                if (kunai.y < 0) kunais.splice(index, 1);
            });

            // Update & Draw Targets
            targets.forEach(target => {
                target.update();
                target.draw();
            });

            // Update & Draw Particles
             particles.forEach((particle, index) => {
                if (particle.alpha <= 0) {
                    particles.splice(index, 1);
                } else {
                    particle.update();
                }
            });

            // Collision Detection
            kunais.forEach((kunai, kIndex) => {
                targets.forEach((target, tIndex) => {
                    const dist = Math.hypot(kunai.x - target.x, kunai.y - target.y);
                    if (dist - target.radius - kunai.width / 2 < 1) {
                        // Hit!
                        score += 100;
                        for (let i = 0; i < target.radius * 2; i++) {
                           particles.push(new Particle(target.x, target.y, Math.random() * 3, '#e74c3c'));
                        }
                        
                        setTimeout(() => {
                            kunais.splice(kIndex, 1);
                            targets.splice(tIndex, 1);
                            
                            // Respawn target based on mode
                            if (gameMode === 'training' || gameMode === 'hard') {
                                if (targets.length === 0) spawnTarget(gameMode === 'hard');
                            } else if (gameMode === 'free') {
                                spawnRandomTarget();
                            }
                        }, 0);
                    }
                });
            });

            // Draw Crosshair
            ctx.drawImage(crosshairImg, crosshair.x - 25, crosshair.y - 25, 50, 50);

            levelUp();
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            crosshair.x = e.clientX - rect.left;
            crosshair.y = e.clientY - rect.top;
        });

        canvas.addEventListener('click', () => {
            if (gameRunning) {
                kunais.push(new Kunai(crosshair.x, crosshair.y));
            }
        });

        document.getElementById('trainingModeBtn').addEventListener('click', () => startGame('training'));
        document.getElementById('freeModeBtn').addEventListener('click', () => startGame('free'));
        document.getElementById('hardModeBtn').addEventListener('click', () => startGame('hard'));
    </script>
</body>
</html>